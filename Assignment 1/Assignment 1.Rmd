---
title: "Assignment 1"
output: 
  pdf_document: 
    keep_tex: yes
date: "2023-02-24"
---
```{r Exercise 1, echo=TRUE, message=TRUE, warning=TRUE}
?co2
summary(co2)
plot(co2)
m <- decompose(co2)
names(m)
plot(m)
plot(decompose(co2, type="additive"))
plot(decompose(co2, type="multiplicative"))
lco2=log(co2)
plot(lco2)
plot(diff(lco2))
plot(diff(lco2, lag=12))
plot(stl(lco2, s.window="periodic"))
# Decomposing the time series shows a positive trend in atmospheric concentrations of CO2 between 1959 and 1997, as well as an annuanl seasonal component.
```

```{r Exercise 2, echo=TRUE}
?UKgas
summary(UKgas)
plot(UKgas)
n <- decompose(co2)
names(n)
plot(n)
plot(decompose(UKgas, type="additive"))
plot(decompose(UKgas, type="multiplicative"))
lUKgas=log(UKgas)
plot(lUKgas)
plot(diff(lUKgas))
plot(diff(lUKgas, lag=12))
plot(stl(lUKgas, s.window="periodic"))
# A multiplicative time series decomposition is better suited because the seasonal component increases in magnitude over time. Taking the logarithm transforms the miltiplicative time series into an additive time series. The logarithmic transformation also paartially stabilizes the variance, although not completely. Taking a first order differences also stabilizes the mean. 
# The 12 month lag removes the trend and the seasonality.
# What is unsatisfactory is that the variance increases over time and cannot be stabilized fully. This is because classical time series decomposition assumes that the seasonal component is constant over time, whereas in this time series, it changes over time, as a percentage of the total, so also when we consider the logarithmic transformation.
HWUKgas <- HoltWinters(UKgas, seasonal = "mult")
plot(HWUKgas)
plot(fitted(HWUKgas))
# Using Holt & Winters exponential smoothing with trend and seasonality we identify a seasonal component that changes over time and a less linear trend.
```

```{r Question 3, echo=TRUE}
?Nile
plot(Nile)
HWNile <- HoltWinters(Nile, beta=F, gamma=F)
HWNile
HWNile$alpha
plot(HWNile, main="Nile data: simple exponential smoothing, alpha=0.24655")
plot(fitted(HWNile))
# The chosen value of alpha is approximately 0.24655.

HWNile1 <- HoltWinters(Nile, alpha=.1, beta=F, gamma=F)
plot(HWNile1, main="Nile data: simple exponential smoothing, alpha=0.1")
HWNile2 <- HoltWinters(Nile, alpha=.9, beta=F, gamma=F)
plot(HWNile2, main="Nile data: simple exponential smoothing, alpha=0.9")
# Setting a parameter closer to 0 allocates less weight to the previous year's observation and more to the level forecast made at time t-1, therefore it varies less over time. A parameter closer to 1 allocates more weight to the previous year's observation, we can see that the forecasted values for alpha=0.9 are almost equal to the values taken by the time series in the previous year.
mape0 = function(Nile, HWNile){ mean(abs(Nile - HWNile)/Nile) }
mape1 = function(Nile, HWNile1){ mean(abs(Nile - HWNile1)/Nile) }
mape2 = function(Nile, HWNile2){ mean(abs(Nile - HWNile2)/Nile) }
```

```{r Question 4, echo=TRUE}
attach(coronavirus.data)
Contagion <- ts(contagion, start = c(2020, 53), end = c(2021, 42), frequency = 365)
Deaths <- ts(deaths, start = c(2020, 53), end = c(2021, 42), frequency = 365)
Tests <- ts(Tests.Tamponi, start = c(2020, 53), end = c(2021, 42), frequency = 365)
Intensive_care <- ts(intesive.care, start = c(2020, 53), end = c(2021, 42), frequency = 365)
Tests_thousands<-Tests/1000
Covid19 <- cbind(Contagion, Deaths, Intensive_care, Tests_thousands)
plot(Covid19)
plot(Contagion, type = "l", main="C19 contagion in Italy", xlab="Date", ylab="C19 contagion cases")
plot(Deaths, type = "l", main="C19 deaths in Italy", xlab="Date", ylab="Number of deaths")
plot(Intensive_care, type = "l", main="C19 intensive care occupation in Italy", xlab="Date", ylab="Intensive care occupants")
plot(Tests_thousands, type = "l", main="C19 tests in Italy", xlab="Date", ylab="C19 tests (thousands)")