---
title: "Problem Set 3 - Group 11"
output: pdf_document
date: "2023-04-05"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.align = "center")

library(depmixS4)
library(ggplot2)
library(tidyverse)
library(data.table)
library(gt)
```

```{r, include = FALSE}
data_assHMM <- read.csv("~/Downloads/data_assHMM.csv")
Real_rates <- ts(data_assHMM$ITAbond_real, start = c(1997, 01), end = c(2019, 07), frequency = 12)
```
The dataset contains data on *nominal interest rate* for the 10-year Italian government bond and the corresponding *inflation rate* represented by the Harmonised Index of Consumer Prices (HICP). The *real interest rate* can be computed by subtracting the inflation rate from the nominal interest rate. Such data is already provided in the dataset.


```{r, echo=FALSE}
plot(Real_rates, type = "o", pch = 19, cex = .3, cex.main = .9, xlab = "Time",
ylab = "Real interest rates", main = "10-year Italian Bond Real Interest Rates")
```

From the plot, we can see that the real interest rate appears to be volatile and exhibits some periods of stability, which suggests that an HMM could be a reasonable model.
The use of HMMs in modeling financial time series has become increasingly popular in recent years, as they can capture the latent states or regimes that govern the behavior of the time series, and provide a flexible framework for modeling the dynamics of the time series. Moreover, HMMs can handle missing data or irregularly spaced observations, which is often the case in financial time series.
Therefore, an HMM could be a reasonable model to capture the latent states or regimes that govern the behavior of the real interest rate in the Italian government bond market.


```{r, include = FALSE}
 y<-as.numeric(Real_rates)
model <- depmix(y~1, data = data.frame(y), nstates = 3)
```

**Model specification:**

We specify the model to have a HMM with three states, and Gaussian emission distributions, with state-dependent mean and variance.

``` {r, echo=FALSE}
model
```

The model specifies the starting values of the unknown parameters: the inital state probabilities $S_{0}$, the transition matrix, and the parameters $\theta_{1} = (\mu_{1}, \sigma_{1})$; $\theta_{2} = (\mu_{2}, \sigma_{2})$. 


**Computation of the MLEs of the unknown parameters (model fitting):**

The model fitting generates the following MLEs for the unknown parameters. We report the output that we get from R.

```{r, include = FALSE}
fmodel <- fit(model)
```
```{r, echo=FALSE}
summary(fmodel)
```
``` {r, include = FALSE}
MLE_mean_st1 <- fmodel@response[[1]][[1]]@parameters$coefficients
MLE_mean_st2 <- fmodel@response[[2]][[1]]@parameters$coefficients
MLE_mean_st3 <- fmodel@response[[3]][[1]]@parameters$coefficients
MLE_sd_st1 <- fmodel@response[[1]][[1]]@parameters$sd
MLE_sd_st2 <- fmodel@response[[2]][[1]]@parameters$sd
MLE_sd_st3 <- fmodel@response[[3]][[1]]@parameters$sd
MLEse=standardError(fmodel)
```

The following table summarizes the **MLEs** and their **associated standard errors** for the initial state probabilities, the transition matrix, and the mean and standard deviation corresponding to the three hidden states.

``` {r, include = FALSE}
dt <- data.table("Coefficient" = round(MLEse$par, 3), "Standard error" = round(MLEse$se, 3))
gt_tbl <- gt(data = dt)
```
```{r, echo=FALSE}
gt_tbl
```


**Decoding:**
``` {r, include = FALSE}
estStates <- posterior(fmodel)
```

We plot the data with the estimated **optimal state sequence**.

```{r, echo=FALSE}
plot(time(Real_rates), estStates[,1], cex.main = .9, cex=.3, xlab = "Time",
     ylab = "Estimated states", main = "Real interest rate and optimal state sequence")
```

We plot the data with the **estimated state-dependent means**.

```{r, include = FALSE}
i = estStates[1, 1]
ii = if (i==1){i+1} else {if (i==2) {i+1} else {i-2}}
iii = if (ii==1){ii+1} else {if (ii==2) {ii+1} else {ii-2}}
estMean1=fmodel@response[[i]][[1]]@parameters$coefficients
estMean2=fmodel@response[[ii]][[1]]@parameters$coefficients
estMean3=fmodel@response[[iii]][[1]]@parameters$coefficients
estMeans=rep(estMean1, length(Real_rates))
estMeans[estStates[,1]==ii]=estMean2
estMeans[estStates[,1]==iii]=estMean3
```
```{r, echo=FALSE}
plot(Real_rates, xlab = "Time", ylab = "Real interest rate")
title(main="Real interest rates data and HMM estimated means", cex.main=1)
points(time(Real_rates), estMeans, col="blue", cex=.3)
```
